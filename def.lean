import tactic
import group_theory.quotient_group

open_locale classical

def df (f : ℤ → ℤ) : ℤ → ℤ → ℤ := λ p q, f (p + q) - f (p) - f (q)

def almost_homo (f : ℤ → ℤ) : Prop := ∃ C, ∀ p q, abs (df f p q) < C 

@[simp] lemma d_equal (f : ℤ → ℤ) (p q : ℤ) : df f p q = f (p + q) - f (p) - f (q) := rfl

def S := {f | almost_homo f}

instance add_group_S : add_group S := {
  add := λ f g, ⟨λ z, f.1 z + g.1 z, begin
    rcases f with ⟨f, C1, hf⟩,
    rcases g with ⟨g, C2, hg⟩,
    use C1 + C2,
    intros p q,
    specialize hf p q,
    specialize hg p q,
    have h1 : df (λ (z : ℤ), f z + g z) p q = df f p q + df g p q,
      simp,
      ring,
    rw h1,
    linarith [abs_add (df f p q) (df g p q)],
  end⟩,
  add_assoc := begin
    intros f g h,
    simp,
    ring,
  end,
  zero := ⟨λ p, 0, begin
    use 1,
    simp,
  end⟩,
  zero_add := begin
    intro f,
    unfold has_add.add,
    simp,
  end,
  add_zero := begin
    intro f,
    unfold has_add.add,
    simp,  
  end,
  neg := λ f, ⟨λ p, - f.1 p, begin
    rcases f with ⟨f, C1, hf⟩,
    use C1,
    simp,
    intros p q,
    specialize hf p q,
    simp at hf,
    have h : f p - f (p + q) + f q = - (f (p + q) - f p - f q),
      ring,
    rw [h, abs_neg],
    exact hf,
  end⟩,
  add_left_neg := begin
    intro f,
    unfold has_add.add add_semigroup.add has_zero.zero,
    simp,
  end }

instance : add_comm_group S := {
  add_comm := begin
    intros f g,
    unfold has_add.add add_semigroup.add has_add.add add_group.add,
    simp,
    simp_rw [add_comm],
  end,
  ..add_group_S }

def B := {f : S | ∃ C, ∀ p, abs (f.1 p) < C}

instance : is_add_subgroup B := {
  zero_mem := begin
    unfold has_zero.zero add_monoid.zero add_group.zero,
    use 1,
    intro p,
    simp,
  end,
  add_mem := begin
    rintro f g ⟨C1, hf⟩ ⟨C2, hg⟩,
    use C1 + C2,
    intro p,
    specialize hf p,
    specialize hg p,
    unfold has_add.add add_semigroup.add add_monoid.add add_group.add,
    simp,
    change abs (f.1 p + g.1 p) < C1 + C2,
    linarith [abs_add (f.1 p) (g.1 p)],
  end,
  neg_mem := begin
    rintro f ⟨C, hf⟩,
    unfold has_neg.neg add_group.neg,
    use C,
    intro p,
    specialize hf p,
    change abs (-(f.val p)) < C,
    simp,
    exact hf,
  end }

def eudoxus_reals_group := quotient_add_group.quotient B
notation `𝔼` := eudoxus_reals_group

instance add_comm_group_𝔼 : add_comm_group 𝔼 := quotient_add_group.add_comm_group B

lemma lemma0 (a b : ℤ) : set.finite {n : ℤ | a < n ∧ n ≤ b} :=
⟨fintype.of_finset (finset.Ico_ℤ (a + 1) (b + 1)) (by {simp [int.add_one_le_iff, int.lt_add_one_iff]})⟩

lemma lemma1 {f : ℤ → ℤ} (hf1 : almost_homo f) (hf2 : set.infinite {n | ∃ p (hp : 0 ≤ p), n = f p ∧ 0 < n}) :
∀ D, 0 < D → ∃ M (hM : 0 < M), ∀ m, 0 < m → (m + 1) * D < f (m * M) :=
begin
  rcases hf1 with ⟨C, hf1⟩,
  intros D hD,
  set E := C + D with hE,
  have key : ∃ M (hM : 0 < M), 2 * E < f M,
    by_contradiction h,
    have h1 : ∀ (M : ℤ) (HM : 0 < M), f M ≤ 2 * E,
      finish,
    have h2 : ∀ fx ∈ {n | ∃ p (hp : 0 ≤ p), n = f p ∧ 0 < n}, fx ≤ max (2 * E) (f 0),
      rintro fx ⟨p, hp, hf, hfx⟩,
      rw le_iff_lt_or_eq at hp,
      cases hp,
        specialize h1 p hp,
        rw hf,
        exact le_max_left_of_le h1,
      rw [hf, ← hp],
      exact le_max_right (2 * E) (f 0),
    set T := max (2 * E) (f 0) with hT,
    have h3 : {n | ∃ p (hp : 0 ≤ p), n = f p ∧ 0 < n} ⊆ {n | 0 < n ∧ n ≤ T},
      rintro fx hfx,
      specialize h2 fx hfx,
      rcases hfx with ⟨_, _, _, hfx⟩,
      use [hfx, h2],
    have h4 : set.finite {n | 0 < n ∧ n ≤ T},
      apply lemma0,
    have h5 : set.finite {n | ∃ p (hp : 0 ≤ p), n = f p ∧ 0 < n},
      exact set.finite.subset h4 h3,
    tauto,
  rcases key with ⟨M, hM, hfM⟩,
  use [M, hM],
  intros m hm,
  have hC : 0 ≤ C,
    specialize hf1 1 2,
    linarith [abs_nonneg (df f 1 2)],
  have hED : ∀ k, 0 < k → (k + 1) * D ≤ (k + 1) * E,
    intros k hk,
    rw mul_le_mul_left,
      linarith,
    linarith,
  apply lt_of_le_of_lt (hED m hm),
  induction m,
  { induction m with m h,
      exfalso,
      exact hm,
    have hm0 : m = 0 ∨ 0 < m,
      exact nat.eq_zero_or_pos m,
    cases hm0,
    { rw hm0,
      simp,
      exact hfM, },
    { have hm0' : int.of_nat m > 0,
        exact int.lt_to_nat.mp hm0,
      specialize h hm0',
      have hdf1 : f ((int.of_nat m.succ) * M) = 
        f (int.of_nat m * M) + f (M) + df f (int.of_nat m * M) (M),
        simp,
        ring,
        rw mul_comm,
      have hdf2 : -E < df f (int.of_nat m * M) M,
        specialize hf1 (int.of_nat m * M) M,
        rw abs_lt at hf1,
        linarith,
      have h1 : (int.of_nat m + 1) * E + 2 * E + (-E) < 
        f (int.of_nat m * M) + f M + df f (int.of_nat m * M) M,
        linarith,
      have h2 : (int.of_nat m.succ + 1) * E = (int.of_nat m + 1) * E + 2 * E + (-E),
        dsimp,
        ring,
      linarith, }, },
  { exfalso,
    exact hm, },
end

theorem QRT : ∀ n m : ℤ, m > 0 → ∃ q r : ℤ, n = m * q + r ∧ (0 ≤ r ∧ r < m) :=
begin
  intros n m h,
  use (n / m),
  use (n % m),
  have HH:  n = m * (n / m)  + (n % m), from calc
    n = n % m + m * (n / m) : by rw [int.mod_add_div]
    ... = m * (n / m) + (n % m) : by rw add_comm,
  have HH1: 0 ≤ (n % m), from int.mod_nonneg n (ne_of_gt h),
  have HH2: (n % m) < m, from calc
    (n % m) < abs m : int.mod_lt n (ne_of_gt h)
    ... = m : abs_of_pos h,
  exact ⟨HH , ⟨HH1, HH2⟩⟩,
end

instance : has_coe_t ↥S 𝔼 := quotient_add_group.has_coe_t

instance : has_lift_t ↥S 𝔼 := coe_to_lift

def P := {e : 𝔼 | ∃ (f : S) (H : ↑f = e), set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n}}

lemma lemma2 (f : S) (hf : set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n}) :
  (∀ C (HC : 0 < C), ∃ N : ℤ, ∀ p (hNp : N < p), C < f.1 p) :=
begin
  rcases f.2 with ⟨D, hD⟩,
  have hD1 : ∀ (p q : ℤ), abs (df f.1 p q) < D := hD,
  specialize hD 1 2,
  have hD' : 0 < D,
    linarith [abs_nonneg (df f.1 1 2)],
  rcases lemma1 f.2 hf D hD' with ⟨M, hM0, hM⟩,
  have hE : ∃ E, ∀ r (h0r : 0 ≤ r) (hrM : r < M), abs(f.1 r) < E,
    have hfin : set.finite ((abs ∘ f.1) '' (set.Ico 0 M)),
      apply set.finite.image,
      split,
      apply fintype.of_finset (finset.Ico_ℤ 0 M),
      simp,
    have hbdd : bdd_above ((abs ∘ f.1) '' (set.Ico 0 M)),
      apply set.finite.bdd_above hfin,
    cases hbdd with m hm,
    unfold upper_bounds at hm,
    simp at hm,
    use m + 1,
    intros r h0r hrM,
    specialize @hm (abs (f.1 r)) r h0r hrM rfl,
    linarith,
  cases hE with E hE,
  have hE1 : ∀ (r : ℤ), 0 ≤ r → r < M → abs (f.1 r) < E := hE,
  specialize hE 0 _ _,
  { set B := E + D with hB,
    intros C hC,
    have hBC0 : 0 < B + C,
      linarith [abs_nonneg (f.1 0)],
    have hn : ∃ n (hn0 : n > 0), B + C < (n + 1) * D,
      rcases (QRT (B + C) D hD') with ⟨n, r, hnr, h0r, hrD⟩,
      rw hnr at hBC0,
      have h0n : 0 ≤ n,
        by_contradiction hfalse,
        simp at hfalse,
        have hnn : ∃ (nn : ℤ) (hnn0 : nn > 0), n = -nn,
          use -n,
          split,
            linarith,
          simp,
        rcases hnn with ⟨nn, hnn0, hnn⟩,
        rw hnn at hBC0,
        have hDnnr : D * nn ≤ r,
          linarith,
        have hDDnn : D ≤ D * nn,
          exact (le_mul_iff_one_le_right hD').mpr hnn0,
        linarith,
      use n + 1,
      split,
        linarith,
      have hfinal : (n + 1 + 1) * D = D * n + 2 * D,
        ring,
      rw hfinal,
      linarith,
    rcases hn with ⟨n, hn0, hn⟩,
    use n * M,
    intros p hp,
    rcases (QRT p M hM0) with ⟨d, r, hdr, h0r, hrM⟩,
    rw hdr at hp,
    have hndr : (n - d) * M < M,
      linarith,
    have hnd : n - d < 1,
      exact (mul_lt_iff_lt_one_left hM0).mp hndr,
    have hnd' : n ≤ d,
      linarith,
    have hd0 : 0 < d,
      linarith,
    have hfdm1 : B + C < f.1 (d * M),
      have hnDdD1 : n + 1 ≤ d + 1,
        linarith,
      have hnDdD2 : (n + 1) * D ≤ (d + 1) * D,
        exact (mul_le_mul_right hD').mpr hnDdD1,
      linarith [hM d hd0],
    have hfdMr : abs (f.1 p - f.1 (d * M)) < B,
      rw hdr,
      have heq1 : f.1 (M * d + r) = f.1 (M * d) + f.1 (r) + df f.1 (M * d) r,
        simp,
        ring,
      have heq2 : f.1 (d * M) + f.1 r + df f.1 (d * M) r - f.1 (d * M) = f.1 r + df f.1 (d * M) r,
        ring,
      rw [heq1, mul_comm, heq2],
      linarith [hD1 (d * M) r, hE1 r h0r hrM, abs_add (f.1 r) (df f.1 (d * M) r)],
    rw abs_lt at hfdMr,
    linarith, },
  { refl, },
  { exact hM0, },
end

lemma lemma3 (S : set ℤ) : int.neg '' (int.neg '' S) = S :=
begin
  tidy,
  convert a_h_left,
    apply neg_neg,
  apply neg_neg,
end

lemma lemma4 (f : S) (hf : set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ n < 0}) :
  (∀ C (HC : 0 < C), ∃ N : ℤ, ∀ p (hNp : N < p), f.1 p < -C) := 
begin
  set g := -f with hgf,
  have hfval : ∀ p, (-f).val p = -(f.val p),
    intro p,
    unfold has_neg.neg add_group.neg,
  have key : ∀ (C : ℤ), 0 < C → (∃ (N : ℤ), ∀ (p : ℤ), N < p → C < g.val p),
    apply lemma2 g,
    simp_rw [hgf, hfval],
    have H1 : set.infinite (int.neg '' {n : ℤ | ∃ (p : ℤ) (hp : 0 ≤ p), n = f.val p ∧ n < 0}),
    { by_contradiction hfalse,
      have hfalse' : (int.neg '' {n : ℤ | ∃ (p : ℤ) (hp : 0 ≤ p), n = f.val p ∧ n < 0}).finite,
        finish,
      have hfalse'' : (int.neg '' (int.neg '' {n : ℤ | ∃ (p : ℤ) (hp : 0 ≤ p), n = f.val p ∧ n < 0})).finite,
        exact set.finite.image int.neg hfalse',
      rw lemma3 at hfalse'',
      finish, },
    have H2 : int.neg '' {n : ℤ | ∃ (p : ℤ) (hp : 0 ≤ p), n = f.val p ∧ n < 0} = 
      {n : ℤ | ∃ (p : ℤ) (hp : 0 ≤ p), n = -f.val p ∧ 0 < n},
      ext,
      split,
      { intro hx,
        rcases hx with ⟨negx, ⟨p, h0p, hp, hnegx0⟩, hnegx⟩,
        use [p, h0p],
        rw ← hnegx,
        split,
          exact congr_arg int.neg hp,
        exact lt_neg.mp hnegx0, },
      { intro hx,
        rcases hx with ⟨p, h0p, hp, h0x⟩,
        use [-x, p, h0p],
          split, 
            rw hp,
            ring,
          exact neg_lt_zero.mpr h0x,
        exact neg_neg x, },
    rw H2 at H1,
    exact H1,
  simp_rw [hgf, hfval] at key,
  rintro C hC,
  specialize key C hC,
  cases key with N key,
  use N,
  intros p hp,
  specialize key p hp,
  linarith,
end

lemma lemma5 (f : S) (hf : ∃ C, ∀ p (hp : 0 ≤ p), abs (f.1 p) < C) : ∃ B, ∀ p, abs (f.1 p) < B :=
begin
  cases f.2 with D hD,
  cases hf with C hC,
  have hneg : ∃ C', ∀ p (hp : p < 0), abs (f.1 p) < C',
    use C + D + abs (f.1 0),
    intros p hp,
    have hfp : f.1 p = f.1 0 - f.1 (-p) - df f.1 (-p) p,
      simp,
      ring,
    rw hfp,
    have hnegp : 0 < -p,
      exact neg_pos.mpr hp,
    have hnegp' : 0 ≤ -p,
      linarith,
    specialize hC (-p) hnegp',
    specialize hD (-p) p,
    have heq : f.val 0 - f.val (-p) - df f.val (-p) p = f.val 0 + (-f.val (-p)) + (-df f.val (-p) p),
      ring,
    rw heq,
    have habs3 : abs (f.val 0 + -f.val (-p) + -df f.val (-p) p) ≤ 
      abs (f.val 0) + abs (-f.val (-p)) + abs (-df f.val (-p) p),
      exact abs_add_three (f.val 0) (-f.val (-p)) (-df f.val (-p) p),
    rw [abs_neg, abs_neg] at habs3,
    linarith [abs_add_three (f.val 0) (-f.val (-p)) (-df f.val (-p) p)],
  cases hneg with C' hC',
  use C + C',
  intro p,
  have hp : 0 ≤ p ∨ p < 0 := le_or_lt 0 p,
  cases hp,
  { specialize hC p hp,
    have hne1 : (-1 : ℤ) < 0,
      norm_num,
    specialize hC' (-1) hne1,
    linarith [abs_nonneg (f.val (-1))], },
  { specialize hC' p hp,
    have h01 : (0 : ℤ) < 1,
      norm_num,
    specialize hC 1 h01,
    linarith [abs_nonneg (f.val 1)], },
end

lemma lemma6 (f : S) : set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n} ∨ 
  set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ n < 0} ∨ (∃ C, ∀ p (hp : 0 ≤ p), abs (f.1 p) < C) :=
begin
  by_cases h1 : set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n},
    left,
    exact h1,
  by_cases h2 : set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ n < 0},
    right,
    left,
    exact h2,
  have h1' : set.finite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n},
    finish,
  have h2' : set.finite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ n < 0},
    finish,  
  have h1bdd : bdd_above {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n} := set.finite.bdd_above h1',
  have h2bdd : bdd_below {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ n < 0} := set.finite.bdd_below h2',
  cases h1bdd with C1 hC1,
  unfold upper_bounds at hC1,
  simp at hC1,
  cases h2bdd with C2 hC2,
  unfold lower_bounds at hC2,
  simp at hC2,
  right,
  right,
  use abs (C1) + abs (C2) + 1,
  intros p hp,
  have hfval0 : 0 < f.1 p ∨ f.1 p ≤ 0,
    exact lt_or_ge 0 (f.val p),
  cases hfval0,
  { specialize @hC1 (f.1 p) p hp rfl hfval0,
    have habs : abs (f.val p) ≤ abs C1,
      apply abs_le_abs hC1,
      linarith,
    linarith [abs_nonneg C2], },
  { have hfval0' : f.1 p < 0 ∨ f.1 p = 0,
      exact lt_or_eq_of_le hfval0,
    cases hfval0',
    { specialize @hC2 (f.1 p) p hp rfl hfval0', 
      have habs : abs (f.val p) ≤ abs C2,
        rw abs_of_neg hfval0',
        have hC2 : C2 < 0,
          linarith,
        rw abs_of_neg hC2,
        linarith,
      linarith [abs_nonneg C1], }, 
    { rw hfval0',
      simp,
      linarith [abs_nonneg C1, abs_nonneg C2], }, },
end

lemma lemma7 (f : S) : (∀ C (HC : 0 < C), ∃ N : ℤ, ∀ p (hNp : N < p), C < f.1 p) ∧ 
  (∀ C (HC : 0 < C), ∃ N : ℤ, ∀ p (hNp : N < p), f.1 p < -C) → false :=
begin
  rintro ⟨h1, h2⟩,
  have h01 : (0 : int) < 1,
    norm_num,
  specialize h1 1 h01,
  specialize h2 1 h01,
  cases h1 with N1 h1,
  cases h2 with N2 h2,
  have hN1 : N1 < abs N1 + abs N2 + 1,
    linarith [abs_nonneg N2, le_abs_self N1],
  have hN2 : N2 < abs N1 + abs N2 + 1,
    linarith [abs_nonneg N1, le_abs_self N2],
  specialize h1 (abs N1 + abs N2 + 1) hN1,
  specialize h2 (abs N1 + abs N2 + 1) hN2,
  linarith,
end

lemma lemma8 (f : S) : (∀ C (HC : 0 < C), ∃ N : ℤ, ∀ p (hNp : N < p), C < f.1 p) ∧ 
  (∃ B, ∀ p, abs (f.1 p) < B) → false :=
begin
  rintro ⟨h1, h2⟩,
  cases h2 with B h2,
    have h01 : (0 : int) < 1,
    norm_num,
  have h2' : ∀ (p : ℤ), abs (f.val p) < B := h2,
  specialize h2' 0,
  have hB : 0 < B,
    linarith [abs_nonneg (f.1 0)],
  specialize h1 B hB,
  cases h1 with N h1,
  have hN : N < N + 1,
    linarith,
  specialize h1 (N + 1) hN,
  specialize h2 (N + 1),
  rw abs_lt at h2,
  linarith,
end

lemma lemma9 (f : S) :  set.infinite {n | ∃ p (hp : 0 ≤ p), n = f.1 p ∧ 0 < n} ↔
  (∀ C (HC : 0 < C), ∃ N : ℤ, ∀ p (hNp : N < p), C < f.1 p) :=
begin
  split,
  { intro hf,
    exact lemma2 f hf, },
  { cases lemma6 f,
    { intro,
      exact h, },
    { cases h,
      { intro h1,
        exfalso,
        exact lemma7 f ⟨h1, lemma4 f h⟩, },
      { intro h1,
        exfalso,
        exact lemma8 f ⟨h1, lemma5 f h⟩, }, }, },
end

lemma lemma10 : ∀ a b ∈ P, a + b ∈ P :=
begin
  rintro a b ⟨f1, hf1a, h1⟩ ⟨f2, hf2b, h2⟩,
  use f1 + f2,
  split,
    rw [← hf1a, ← hf2b],
    refl,
  rw lemma9 at *,
  intros C hC,
  specialize h1 C hC,
  specialize h2 C hC,
  cases h1 with M h1,
  cases h2 with N h2,
  use max M N,
  intro p,
  intro hMNp,
  have hMNp': M < p ∧ N < p,
    rw ← max_lt_iff,
    exact hMNp,
  specialize h1 p hMNp'.1,
  specialize h2 p hMNp'.2,
  have hfinal : (f1 + f2).val p = f1.val p + f2.val p,
    refl,
  rw hfinal,
  linarith,
end

lemma lemma11 : (0 : 𝔼) ∈ P → false :=
begin
  intro hfalse,
  unfold P at hfalse,
  rcases hfalse with ⟨f, H, hfalse⟩,
  rw lemma9 at hfalse,
  unfold has_zero.zero add_monoid.zero add_group.zero add_comm_group.zero at H,
  rw quotient_add_group.eq at H,
  have hf : -f + 0 ∈ B,
    unfold has_zero.zero add_monoid.zero add_group.zero,
    exact H,
  unfold B at hf,
  simp at hf,
  change ∃ (C : ℤ), ∀ (p : ℤ), abs (((-f).val) p) < C at hf,
  have hfval : ∀ p, (-f).val p = -(f.val p),
    intro p,
    refl,
  simp_rw [hfval, abs_neg] at hf,
  exact lemma8 f ⟨hfalse, hf⟩,
end

lemma lemma12 {a : 𝔼} : a ∈ P → -a ∈ P → false :=
begin
  unfold P,
  rintro ⟨f1, hf1, ha1⟩ ⟨f2, hf2, ha2⟩,
  rw ← hf1 at hf2,
  have hf1f2 : ↑f2 + ↑f1 = (0 : 𝔼), 
    rw hf2,
    simp,
  have hf1f2' : (@coe ↥S 𝔼) eudoxus_reals_group.has_lift_t (0 : S) = ↑(f2 + f1), 
    have heq : (@coe ↥S 𝔼) eudoxus_reals_group.has_lift_t (f2 + f1) = ↑f2 + ↑f1,
      refl,
    have h0 : (@coe ↥S 𝔼) eudoxus_reals_group.has_lift_t (0 : S) = (0 : 𝔼),
      refl,
    rw [heq, h0, ← hf1f2],
  rw quotient_add_group.eq at hf1f2',
  simp at hf1f2',
  unfold B at hf1f2',
  cases hf1f2' with C hf1f2',
  rw lemma9 at *,
  have h0C : 0 < C,
    linarith [hf1f2' 0, abs_nonneg ((f2 + f1).val 0)],
  cases ha1 C h0C with N1 ha1,
  cases ha2 C h0C with N2 ha2,
  have hN1 : N1 < max N1 N2 + 1,
    linarith [le_max_left N1 N2],
  have hN2 : N2 < max N1 N2 + 1,
    linarith [le_max_right N1 N2],
  specialize ha1 (max N1 N2 + 1) hN1,
  specialize ha2 (max N1 N2 + 1) hN2,
  specialize hf1f2' (max N1 N2 + 1),
  have heq : (f2 + f1).val (max N1 N2 + 1) = f2.val (max N1 N2 + 1) + f1.val (max N1 N2 + 1) := rfl,
  rw [heq, abs_lt] at hf1f2',
  linarith,
end

instance ordered_add_comm_group_𝔼 : ordered_add_comm_group 𝔼 :=
{ le := λ a b, -a + b ∈ P ∪ {0},
  lt := λ a b, -a + b ∈ P,
  le_refl := begin
    intro a,
    simp,
  end,
  le_trans := begin
    intros a b c hab hbc,
    simp at *,
    cases hab,
    { cases hbc,
      { left,
        rw [neg_add_eq_zero.mp hab, neg_add_eq_zero.mp hbc],
        simp, },
      { rw neg_add_eq_zero.mp hab,
        cc, }, },
    { cases hbc,
      { rw ← (neg_add_eq_zero.mp hbc),
        cc, },
      { right,
        have h : (-a + b) + (-b + c) ∈ P := lemma10 (-a + b) (-b + c) hab hbc,
        have heq : -a + c = (-a + b) + (-b + c),
          abel,
        rw heq,
        exact h, }, },
  end,
  lt_iff_le_not_le := begin
    intros a b,
    split,
    { intro hab,
      simp at hab,
      simp,
      split,
        cc,
      intro hfalse,
      cases hfalse,
      { rw neg_add_eq_zero.mp hfalse at hab,
        simp at hab,
        exact lemma11 hab, },
      { have heq : -b + a = -(-a + b),
          abel,
        rw heq at hfalse,
        exact lemma12 hab hfalse, }, },
    { rintro ⟨hab, hba⟩,
      cases hab,
      { exact hab, },
      { simp at hab,
        simp at hba,
        have : ¬(-b + a = 0),
          cc,
        exfalso,
        apply this,
        rw neg_add_eq_zero at *,
        exact eq.symm hab, }, },
  end,
  le_antisymm := begin
    intros a b hab hba,
    cases hab,
    { cases hba,
      { exfalso,
        have :  -b + a = -(-a + b),
          abel,
        rw this at hba,
        exact lemma12 hab hba, },
      { simp at hba,
        exact eq.symm (neg_add_eq_zero.mp hba), }, },
    { simp at hab,
      exact neg_add_eq_zero.mp hab, },
  end,
  add_le_add_left := begin
    intros a b hab c,
    show -(c + a) + (c + b) ∈ P ∪ {0},
    have : -(c + a) + (c + b) = -a + b,
      abel,
    rw this,
    exact hab,
  end,
  ..add_comm_group_𝔼 }

lemma lemma13 : ∀ a : 𝔼, ∃ f : S, ↑f = a := λ a, quot.exists_rep a

lemma lemma14 : ∀ {f : ℤ → ℤ} (C : ℤ), set.finite (f '' (set.Ioo (-C) C)) :=
begin
  intros f C,
  apply set.finite.image,
  exact ⟨fintype.of_finset (finset.Ico_ℤ (-C + 1) (C)) (by {simp [int.add_one_le_iff]})⟩,
end

lemma lemma15 : ∀ f g : S, f.1 ∘ g.1 ∈ S :=
begin
  intros f g,
  rcases f with ⟨f, C1, hf⟩,
  rcases g with ⟨g, C2, hg⟩,
  simp,
  have hfin : set.finite (f '' (set.Ioo (-C2) (C2))) := lemma14 C2,
  cases set.finite.bdd_above hfin with C3 hC3,
  unfold upper_bounds at hC3,
  simp at hC3,
  cases set.finite.bdd_below hfin with C4 hC4,
  unfold lower_bounds at hC4,
  simp at hC4,
  use C1 + C1 + max (abs (C4)) (abs (C3)),
  unfold df at *,
  intros p q,
  have hf' := hf,
  set t := g (p + q) - g p - g q with ht,
  have heq : g (p + q) = t + (g p + g q),
    rw ht,
    ring,
  specialize hf (g p) (g q),
  specialize hg p q,
  specialize hf' t (g p + g q),
  rw [← ht, abs_lt] at hg,
  specialize @hC3 (f t) t hg.1 hg.2 rfl,
  specialize @hC4 (f t) t hg.1 hg.2 rfl,
  rw ← heq at hf',
  have h123 : abs ((f (g p + g q) - f (g p) - f (g q)) + (f (g (p + q)) - f t - f (g p + g q)) + f t)
    ≤ abs (f (g p + g q) - f (g p) - f (g q)) + abs (f (g (p + q)) - f t - f (g p + g q)) + abs (f t),
    exact abs_add_three (f (g p + g q) - f (g p) - f (g q)) (f (g (p + q)) - f t - f (g p + g q)) (f t),
  have heq : (f (g p + g q) - f (g p) - f (g q)) + (f (g (p + q)) - f t - f (g p + g q)) + f t = 
    (f ∘ g) (p + q) - (f ∘ g) p - (f ∘ g) q,
    ring,
  rw heq at h123,
  have hft : abs (f t) ≤ max (abs (C4)) (abs (C3)),
    apply abs_le_max_abs_abs hC4 hC3,
  linarith,
end

lemma lemma16 : ∀ {f1 g1 f2 g2 : S}, (@coe ↥S 𝔼) eudoxus_reals_group.has_lift_t f1 = ↑f2 → 
  (@coe ↥S 𝔼) eudoxus_reals_group.has_lift_t g1 = ↑g2 → -(⟨f1.1 ∘ g1.1, lemma15 f1 g1⟩ : S) 
  + (⟨f2.1 ∘ g2.1, lemma15 f2 g2⟩ : S) ∈ B :=
begin
  rintros ⟨f1, hf1⟩ ⟨g1, hfg⟩ ⟨f2, Bf2, hf2⟩ ⟨g2, hg2⟩ hf1f2 hg1g2,
  rw quotient_add_group.eq at *,
  unfold B at *,
  cases hf1f2 with Cf hf1f2,
  cases hg1g2 with Cg hg1g2,
  have hfin : set.finite (f2 '' (set.Ioo (-Cg) (Cg))) := lemma14 Cg,
  cases set.finite.bdd_above hfin with C3 hC3,
  unfold upper_bounds at hC3,
  simp at hC3,
  cases set.finite.bdd_below hfin with C4 hC4,
  unfold lower_bounds at hC4,
  simp at hC4,
  use Cf + Bf2 + max (abs (C4)) (abs (C3)),
  unfold df at hf2,
  intros x,
  set t := (g1 x).neg + g2 x with ht,
  have htrivial : ∀ (a : ℤ), a.neg = -a, 
    intro a, 
    refl,
  have heq : g2 x = t + g1 x,
    have := htrivial (g1 x),
    rw [ht, this],
    ring,
  specialize hf1f2 (g1 x),
  specialize hg1g2 x,
  specialize hf2 t (g1 x),
  unfold has_add.add add_semigroup.add add_semigroup.add add_monoid.add add_group.add 
    has_neg.neg add_group.neg at hf1f2,
  simp at hf1f2,
  unfold has_add.add add_semigroup.add add_semigroup.add add_monoid.add add_group.add 
    has_neg.neg add_group.neg at hg1g2,
  simp at hg1g2,
  rw [← ht, abs_lt] at hg1g2,
  specialize @hC3 (f2 t) t hg1g2.1 hg1g2.2 rfl,
  specialize @hC4 (f2 t) t hg1g2.1 hg1g2.2 rfl,
  rw ← heq at hf2,
  unfold has_add.add add_semigroup.add add_semigroup.add add_monoid.add add_group.add 
    has_neg.neg add_group.neg,
  simp,
  have h123 := abs_add_three ((f1 (g1 x)).neg + f2 (g1 x)) (f2 (g2 x) - f2 t - f2 (g1 x)) (f2 t),
  have heq : ((f1 (g1 x)).neg + f2 (g1 x)) + (f2 (g2 x) - f2 t - f2 (g1 x)) + f2 t = 
    (f1 (g1 x)).neg + f2 (g2 x),
    have hf1g1n := htrivial (f1 (g1 x)),
    rw hf1g1n,
    ring,
  rw heq at h123,
  have hft : abs (f2 t) ≤ max (abs (C4)) (abs (C3)),
    apply abs_le_max_abs_abs hC4 hC3,
  linarith,
end

lemma lemma17 : (id : ℤ → ℤ) ∈ S := 
begin
  use 1,
  intros p q,
  simp,
end

noncomputable def 𝔼.mul : 𝔼 → 𝔼 → 𝔼 := λ a b, 
begin
  choose f hf using lemma13 a,
  choose g hg using lemma13 b,
  let h : ↥S := ⟨f.1 ∘ g.1, lemma15 f g⟩,
  exact ↑h,
end

lemma lemma18 : ∀ x y : S, 𝔼.mul x y = ↑(⟨x.1 ∘ y.1, lemma15 x y⟩ : S) :=
begin
  intros x y,
  unfold 𝔼.mul,
  rw quotient_add_group.eq,
  have hxeq := classical.some_spec (lemma13 ↑x),
  have hyeq := classical.some_spec (lemma13 ↑y),
  apply lemma16 hxeq hyeq,
end

lemma lemma19 : ∀ x y : S, x = y → -x + y ∈ B :=
begin
  intros x y hxy,
  rw hxy,
  simp,
  use 1,
  intro p,
  simp,
end

lemma lemma20 (f : S) : ∃ C, ∀ p (H : 0 ≤ p) q, abs (f.1 (p * q) - p * (f.1 q)) < (abs p + 1) * C :=
begin
  cases f.2 with C hC,
  use C,
  intros p H,
  induction p,
  { induction p with p hp,
    { intro q,
      simp,
      change abs (f.1 0) < C,
      have hf0 : abs (f.1 0) = abs (f.1 (0 + 0) - f.1 0 - f.1 0),
        simp,
      have hdf0 : df f.1 0 0 = f.1 (0 + 0) - f.1 0 - f.1 0 := rfl,
      rw [hf0, ← hdf0],
      exact hC 0 0, },
    { intro q,
      specialize hp (int.of_nat_nonneg p) q,
      have hkey : f.val (int.of_nat p.succ * q) - f.1 (p * q) - f.1 q = df f.1 (p * q) q,
        simp,
        ring,
      specialize hC (p * q) q,
      rw ← hkey at hC,
      have heq : f.val (int.of_nat p.succ * q) - int.of_nat p.succ * f.val q = 
        (f.val (int.of_nat p.succ * q) - f.val (↑p * q) - f.val q) + (f.val (int.of_nat p * q) - 
        int.of_nat p * f.val q),
        simp,
        ring,
      rw heq,
      have : (abs (int.of_nat p.succ) + 1) * C = C + (abs (int.of_nat p) + 1) * C,
        have hp1 : 0 < (↑p : ℤ) + 1,
          linarith,
        simp,
        rw [abs_of_pos hp1],
        ring,
      linarith [abs_add (f.val (int.of_nat p.succ * q) - f.val (↑p * q) - f.val q) (f.val (int.of_nat p * q) - 
        int.of_nat p * f.val q)], }, },
    { exfalso,
      linarith [int.neg_succ_lt_zero p], },
end

lemma lemma21 (f : S) : ∃ C, ∀ p (H : 0 ≤ p) q, abs (f.1 ((-p) * q) - (-p) * (f.1 q)) < (abs (-p) + 1) * C :=
begin
  cases f.2 with C hC,
  use C,
  intros p H,
  induction p,
  { induction p with p hp,
    { intro q,
      simp,
      change abs (f.1 0) < C,
      have hf0 : abs (f.1 0) = abs (f.1 (0 + 0) - f.1 0 - f.1 0),
        simp,
      have hdf0 : df f.1 0 0 = f.1 (0 + 0) - f.1 0 - f.1 0 := rfl,
      rw [hf0, ← hdf0],
      exact hC 0 0, },
    { intro q,
      specialize hp (int.of_nat_nonneg p) q,
      have hkey : -f.1 (-int.of_nat p.succ * q) + f.1 (-(p * q)) - f.1 q = df f.1 (-(p + 1) * q) q,
        simp,
        have heq : (-1 + -↑p) * q + q = -(↑p * q),
          ring,
        rw heq,
        ring,
      specialize hC (-(↑p + 1) * q) q,
      rw ← hkey at hC,
      have heq : f.val (-int.of_nat p.succ * q) - -int.of_nat p.succ * f.val q = 
        -(-f.val (-int.of_nat p.succ * q) + f.val (-(p * q)) - f.val q) + (f.val (-int.of_nat p * q) - 
        -int.of_nat p * f.val q),
        simp,
        ring,
      rw heq,
      have : (abs (-int.of_nat p.succ) + 1) * C = C + (abs (-int.of_nat p) + 1) * C,
        have hp1 : 0 ≤ (↑p : ℤ) := int.of_nat_nonneg p,
        have hp2 : -1 + -(↑p : ℤ) < 0,
          linarith,
        simp,
        rw [abs_of_neg hp2],
        ring,
      have := abs_add (-(-f.val (-int.of_nat p.succ * q) + f.val (-(p * q)) - f.val q)) (f.val (-int.of_nat p * q) - 
        -int.of_nat p * f.val q),
      rw abs_neg at this,
      linarith, }, },
    { exfalso,
      linarith [int.neg_succ_lt_zero p], },
end

lemma lemma22 (f : S) : ∃ C, ∀ p q,  abs (f.1 (p * q) - p * (f.1 q)) < (abs p + 1) * C :=
begin
  cases lemma20 f with C1 hC1,
  cases lemma21 f with C2 hC2,
  use max C1 C2,
  intro p,
  have hp0 := le_or_lt 0 p,
  cases hp0,
  { intro q,
    specialize hC1 p hp0 q,
    have := le_max_left C1 C2,
    have h0abs : 0 < abs p + 1,
      linarith [abs_nonneg p],
    have : (abs p + 1) * C1 ≤ (abs p + 1) * max C1 C2,
      have := @mul_le_mul_left ℤ (linear_ordered_ring.to_linear_ordered_semiring) C1 (max C1 C2) (abs p + 1),
      rw this,
        exact le_max_left C1 C2,
      linarith,
    linarith, },
  { intro q,
    set np := -p with hnp,
    have hnp0 : 0 ≤ np,
      linarith,
    specialize hC2 np hnp0 q,
    have hnpp : -np = p,
      rw hnp,
      simp,
    rw hnpp at hC2,
    have := le_max_left C1 C2,
    have h0abs : 0 < abs p + 1,
      linarith [abs_nonneg p],
    have : (abs p + 1) * C2 ≤ (abs p + 1) * max C1 C2,
      have := @mul_le_mul_left ℤ (linear_ordered_ring.to_linear_ordered_semiring) C2 (max C1 C2) (abs p + 1),
      rw this,
        exact le_max_right C1 C2,
      linarith,
    linarith, },
end

lemma lemma23 (f : S) : ∃ C, ∀ p q, abs (p * (f.1 q) - q * (f.1 p)) < (abs p + abs q + 2) * C :=
begin
  cases lemma22 f with C hC,
  use C,
  intros p q,
  have hC' := hC,
  specialize hC p q,
  specialize hC' q p,
  rw ← abs_neg at hC,
  have heq1 : (-(f.val (p * q) - p * f.val q)) + (f.val (q * p) - q * f.val p) = p * f.val q - q * f.val p,
    rw mul_comm,
    ring,
  have heq2 : (abs p + abs q + 2) * C = ((abs p + 1) * C) + ((abs q + 1) * C),
    ring,
  rw [← heq1, heq2],
  linarith [abs_add (-(f.val (p * q) - p * f.val q)) (f.val (q * p) - q * f.val p)],
end

lemma lemma24 (f : S) : ∃ A B, ∀ p, abs (f.1 p) < A * abs p + B :=
begin
  cases lemma23 f with C hC,
  use [C + abs (f.1 1), 3 * C],
  intro p,
  specialize hC p 1,
  have heq1 : f.1 p = -(p * f.1 1 - f.1 p) + (p * f.1 1),
    ring,
  have heq2 : (C + abs (f.val 1)) * abs p + 3 * C = (abs p + 1 + 2) * C + abs (p * f.1 1),
    have : abs (p * f.1 1) = (abs p) * abs (f.1 1) := abs_mul p (f.1 1),
    rw this,
    ring,
  rw [heq1, heq2],
  simp at hC,
  change abs (p * f.1 1 - f.1 p) < (abs p + 1 + 2) * C at hC,
  rw ← abs_neg at hC,
  linarith [abs_add (-(p * f.val 1 - f.val p)) (p * f.1 1)],
end

lemma lemma25 (f g : S) : ∃ D E, ∀ p, abs p * abs (f.1 (g.1 p) - g.1 (f.1 p)) < D * abs p + E :=
begin
  have h1 : ∃ C, ∀ p, abs (p * f.1 (g.1 p) - g.1 p * f.1 p) < (abs p + abs (g.1 p) + 2) * C,
    cases lemma23 f with C hC,
    use C,
    intro p,
    specialize hC p (g.1 p),
    exact hC,
  have h2 : ∃ C, ∀ p, abs (g.1 p * f.1 p - p * g.1 (f.1 p)) < (abs p + abs (f.1 p) + 2) * C,
    cases lemma23 g with C hC,
    use C,
    intro p,
    specialize hC p (f.1 p),
    have heq : p * g.val (f.val p) - f.val p * g.val p = -(g.val p * f.val p - p * g.val (f.val p)),
      ring,
    rw [heq, abs_neg] at hC,
    exact hC,
  have h3 : ∃ C, ∀ p, abs (p * f.1 (g.1 p) - p * g.1 (f.1 p)) < (2 * abs p + abs (g.1 p) + abs (f.1 p) + 4) * C,
    cases h1 with C1 h1,
    cases h2 with C2 h2,
    use max C1 C2,
    intro p,
    specialize h1 p,
    specialize h2 p,
    have h0abs1 : 0 < abs p + abs (g.val p) + 2,
      linarith [abs_nonneg p, abs_nonneg (g.val p)],
    have h0abs2 : 0 < abs p + abs (f.val p) + 2,
      linarith [abs_nonneg p, abs_nonneg (f.val p)],
    have : (abs p + abs (g.val p) + 2) * C1 ≤ (abs p + abs (g.val p) + 2) * max C1 C2,
      have := @mul_le_mul_left ℤ (linear_ordered_ring.to_linear_ordered_semiring) C1 (max C1 C2) (abs p + abs (g.val p) + 2),
      rw this,
        exact le_max_left C1 C2,
      linarith,
    have : (abs p + abs (f.val p) + 2) * C2 ≤ (abs p + abs (f.val p) + 2) * max C1 C2,
      have := @mul_le_mul_left ℤ (linear_ordered_ring.to_linear_ordered_semiring) C2 (max C1 C2) (abs p + abs (f.val p) + 2),
      rw this,
        exact le_max_right C1 C2,  
      linarith,    
    have heq1 : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * max C1 C2 = 
      (abs p + abs (g.val p) + 2) * max C1 C2 + (abs p + abs (f.val p) + 2) * max C1 C2,
      ring,
    have heq2 : p * f.val (g.val p) - p * g.val (f.val p) = (p * f.1 (g.1 p) - g.1 p * f.1 p) +
      (g.1 p * f.1 p - p * g.1 (f.1 p)),
      ring,
    rw [heq1, heq2],
    linarith [abs_add (p * f.1 (g.1 p) - g.1 p * f.1 p) (g.1 p * f.1 p - p * g.1 (f.1 p))],
  cases h3 with C h3,
  rcases lemma24 f with ⟨Af, Bf, hABf⟩,
  rcases lemma24 g with ⟨Ag, Bg, hABg⟩,  
  have h4 : ∀ (p : ℤ), abs (p * f.val (g.val p) - p * g.val (f.val p)) < 
    (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
    intro p,
    specialize hABf p,
    specialize hABg p,
    specialize h3 p,
    have h0abs : 0 < (2 * abs p + abs (g.val p) + abs (f.val p) + 4),
      linarith [abs_nonneg p, abs_nonneg (g.val p), abs_nonneg (f.val p)],
    have : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * C < 
      (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
      have hfvalgval : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) < 
        (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4),
        linarith,
      apply mul_lt_mul hfvalgval (le_refl C),
        have := abs_nonneg (p * f.val (g.val p) - p * g.val (f.val p)),
        have h0mul : 0 < (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * C,
          linarith,
        have : 0 < C,
          exact (zero_lt_mul_left h0abs).mp h0mul,
        linarith,
      linarith, 
    linarith,
  use [(2 + Ag + Af) * C, (Bg + Bf + 4) * C],
  intro p,
  specialize h4 p,
  have heq1 : (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C = 
    (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
    ring,
  have heq2 : abs p * abs (f.val (g.val p) - g.val (f.val p)) = 
    abs (p * f.val (g.val p) - p * g.val (f.val p)),
    have := (abs_mul p (f.val (g.val p) - g.val (f.val p))).symm,
    convert this,
    ring,
  linarith,
end

lemma lemma26 (f g : S) : -(⟨f.1 ∘ g.1, lemma15 f g⟩ : S) + (⟨g.1 ∘ f.1, lemma15 g f⟩ : S) ∈ B :=
begin
  rcases lemma25 f g with ⟨D, E, hDE⟩,
  unfold B,
  have : ∀ (k : S), k ∈ {f : ↥S | ∃ (C : ℤ), ∀ (p : ℤ), abs (f.val p) < C} ↔ ∃ (C : ℤ), ∀ (p : ℤ), abs (k.val p) < C,
    intro k,
    refl,
  rw this,
  clear this,
  simp,
  unfold has_add.add add_semigroup.add add_monoid.add add_group.add has_neg.neg add_group.neg,
  simp,
  change ∃ (C : ℤ), ∀ (p : ℤ), abs (-(f.1 (g.1 p)) + g.1 (f.1 p)) < C,
  have h1 : ∀ p (H : abs E < abs p), abs (f.val (g.val p) - g.val (f.val p)) < D + 1,
    intros p hp,
    specialize hDE p,
    have hDE' : abs p * abs (f.val (g.val p) - g.val (f.val p)) < D * abs p + abs E,
      linarith [le_abs_self E],
    have : abs p * abs (f.val (g.val p) - g.val (f.val p)) < abs p * (D + 1),
      linarith,
    have habsp : abs p > 0, 
      linarith [abs_nonneg E],
    have hiff := @mul_lt_mul_left ℤ (linear_ordered_ring.to_linear_ordered_semiring) (abs (f.val (g.val p) - g.val (f.val p)))
      (D + 1) (abs p) habsp,
    rw ← hiff,
    exact this,
  have hB : ∃ B, ∀ (p : ℤ), abs p ≤ abs E → abs (f.val (g.val p) - g.val (f.val p)) < B,
    have hfin : set.finite ((λ p, abs (f.val (g.val p) - g.val (f.val p))) '' (set.Icc (-(abs E)) (abs E))),
      apply set.finite.image,
      exact ⟨fintype.of_finset (finset.Ico_ℤ (-(abs E)) (abs E + 1)) (by {simp [int.lt_add_one_iff]})⟩,
    have hbdd : bdd_above ((λ p, abs (f.val (g.val p) - g.val (f.val p))) '' (set.Icc (-(abs E)) (abs E))),
      apply set.finite.bdd_above hfin,
    cases hbdd with m hm,
    unfold upper_bounds at hm,
    simp at hm,
    use m + 1,
    intros p hpE,
    rw abs_le at hpE,
    specialize @hm (abs (f.val (g.val p) - g.val (f.val p))) p hpE.1 hpE.2 rfl,
    linarith,
  cases hB with B hB,
  use max B (D + 1),
  intro p,
  rw ← abs_neg,
  have : -(-f.val (g.val p) + g.val (f.val p)) = f.val (g.val p) - g.val (f.val p),
    ring,
  rw this,
  have hpE := le_or_lt (abs p) (abs E),
  cases hpE,
    specialize hB p hpE,
    linarith [le_max_left B (D + 1)],
  specialize h1 p hpE,
  linarith [le_max_right B (D + 1)],
end

lemma 𝔼.mul_comm : ∀ (a b : 𝔼), 𝔼.mul a b = 𝔼.mul b a :=
begin
  intros a b,
  cases lemma13 a with u hu,
  cases lemma13 b with v hv,
  rw [← hu, ← hv, lemma18 u v, lemma18 v u, quotient_add_group.eq],
  apply lemma26,
end

lemma 𝔼.mul_right_distrib : ∀ (a b c : 𝔼), 𝔼.mul (a + b) c = 𝔼.mul a c + 𝔼.mul b c :=
begin
  intros a b c,
  cases lemma13 a with u hu,
  cases lemma13 b with v hv,
  cases lemma13 c with w hw,
  have H1 := lemma18 (u + v) w,
  have H2 := lemma18 u w,
  have H3 := lemma18 v w,
  have heq : ∀ v w, (@coe ↥S 𝔼) eudoxus_reals_group.has_lift_t (v + w) = 
    @has_add.add 𝔼 (@add_semigroup.to_has_add 𝔼 (add_monoid.to_add_semigroup 𝔼)) ↑v ↑w := λ v w, rfl,
  rw heq at H1,
  rw [← hu, ← hv, ← hw],
    rw [H1, H2, H3, ← heq, quotient_add_group.eq],
    simp,
    apply lemma19,
    unfold has_add.add add_semigroup.add add_monoid.add add_group.add,
    simp,
end

noncomputable instance comm_ring_𝔼 : comm_ring 𝔼 := {
  mul := 𝔼.mul,
  mul_assoc := begin
    intros a b c,
    cases lemma13 a with u hu,
    cases lemma13 b with v hv,
    cases lemma13 c with w hw,
    set ab : ↥S := ⟨u.1 ∘ v.1, lemma15 u v⟩ with hab, 
    set abc : ↥S := ⟨ab.1 ∘ w.1, lemma15 ab w⟩ with habc,
    set bc : ↥S := ⟨v.1 ∘ w.1, lemma15 v w⟩ with hbc,
    set abc' : ↥S := ⟨u.1 ∘ bc.1, lemma15 u bc⟩ with habc',  
    have H1 := lemma18 u v,
    have H2 := lemma18 ab w,
    have H3 := lemma18 v w,
    have H4 := lemma18 u bc,
    rw [hu, hv] at H1,
    rw [hab, ← habc, ← H1, hw] at H2,
    rw [hv, hw] at H3,
    rw [hbc, ← habc', ← H3, hu] at H4,
    unfold has_mul.mul,
    rw [H2, H4],
  end,
  one := ↑(⟨(id : ℤ → ℤ), lemma17⟩ : S),
  one_mul := begin
    intro a,
    cases lemma13 a with u hu,
    rw ← hu,
    unfold has_one.one has_mul.mul semigroup.mul 𝔼.mul,
    simp,
    rw quotient_add_group.eq,
    have h1 := classical.some_spec (lemma13 ↑u),
    have h2 := classical.some_spec (lemma13 ↑(⟨(id : ℤ → ℤ), lemma17⟩ : S)),
    have h3 := lemma16 h2 h1,
    have h4 : u = (⟨(⟨(id : ℤ → ℤ), lemma17⟩ : S).val ∘ u.val, lemma15 ⟨(id : ℤ → ℤ), lemma17⟩ u⟩ : S),
      simp,
    rw h4,
    convert h3,
    simp,
  end,
  mul_one := begin
    intro a,
    cases lemma13 a with u hu,
    rw ← hu,
    unfold has_one.one has_mul.mul semigroup.mul 𝔼.mul,
    simp,
    rw quotient_add_group.eq,
    have h1 := classical.some_spec (lemma13 ↑u),
    have h2 := classical.some_spec (lemma13 ↑(⟨(id : ℤ → ℤ), lemma17⟩ : S)),
    have h3 := lemma16 h1 h2,
    have h4 : u = (⟨(⟨(id : ℤ → ℤ), lemma17⟩ : S).val ∘ u.val, lemma15 ⟨(id : ℤ → ℤ), lemma17⟩ u⟩ : S),
      simp,
    rw h4,
    convert h3,
    simp,
  end,
  left_distrib := begin
    intros a b c,
    unfold has_mul.mul,
    rw [𝔼.mul_comm],
    have := 𝔼.mul_comm a c,
    symmetry,
    rw [𝔼.mul_comm, this],
    symmetry,
    apply 𝔼.mul_right_distrib,
  end,
  right_distrib := begin
    intros a b c,
    unfold has_mul.mul,
    apply 𝔼.mul_right_distrib,
  end, 
  mul_comm := begin
    intros a b,
    unfold has_mul.mul,
    apply 𝔼.mul_comm,
  end,
  ..add_comm_group_𝔼 }

